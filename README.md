# Домашнее задание к занятию "`Базы данных, их типы`" - `Милованов Константин`
[Домашнее задание](https://github.com/netology-code/sdb-homeworks/blob/main/11-01.md)


### Задание 1. СУБД

Кейс

Крупная строительная компания, которая также занимается проектированием и девелопментом, решила создать правильную архитектуру для работы с данными. Ниже представлены задачи, которые необходимо решить для каждой предметной области.

Какие типы СУБД, на ваш взгляд, лучше всего подойдут для решения этих задач и почему?

1.1. Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков. СУБД должна гарантировать целостность и чёткую структуру данных.
```
Ответ: Реляционная (SQL) СУБД. Реляционные БД идеально подходят для структурированных финансовых данных.
```

1.1.* Хеширование стало занимать длительно время, какое API можно использовать для ускорения работы?

Ответ: зависит от того, где возросла нагрузка. Использовать встроенные криптографические функции СУБД или вынести вычисление хешей на уровень приложения с использованием оптимизированных библиотек. Встроенные функции СУБД часто оптимизированы и выполняются ближе к данным, что снижает задержки. Но если проблема в нагрузке на CPU СУБД, вынос этой задачи на бэкенд-сервер приложения позволит масштабировать её независимо от СУБД.


1.2. Под каждый девелоперский проект создаётся отдельный лендинг, и все данные по лидам стекаются в CRM к маркетологам и менеджерам по продажам. Какой тип СУБД лучше использовать для лендингов и для CRM? СУБД должны быть гибкими и быстрыми.
```
Ответ: Для лендингов: Документная NoSQL СУБД и/или для сессий и кэширования быстрая ключ-значение БД (например, Redis). Если создаются отдельные лендинги с разными шаблонами, то Документная noSQL подходит.
Для CRM: Реляционная SQL БД. CRM требует целостности данных, сложных связей, транзакционности. Однако, если структура взаимодействий с клиентом очень динамична, можно рассмотреть документную БД или графовую для анализа связей.
```

1.2.* Можно ли эту задачу закрыть одной СУБД? И если да, то какой именно СУБД и какой реализацией?
```
Ответ: можно с PostgreSQL. Но с компромиссами по гибкости и скорости. PostgreSQL сочетает мощность реляционной модели с возможностями NoSQL (JSONB, индексирование JSON), JSONB для хранения динамических данных с лендингов (поля формы, UTM-метки). Использовать обычные реляционные таблицы со строгой схемой для сущностей CRM. Но для максимальной производительности лендингов можно добавить Redis как кэширующий слой и хранилище сессий, оставив PostgreSQL в качестве основного хранилища (системы записи).
```

1.3. Отдел контроля качества решил создать базу по корпоративным нормам и правилам, обучающему материалу и так далее, сформированную согласно структуре компании. СУБД должна иметь простую и понятную структуру.
```
Ответ: чаще всего для этого используют wiki-движки, которые часто используют реляционные БД. Подойдет реляционная (SQL) СУБД. Структура компании иерархична, а знания должны быть связаны с этими узлами. Реляционная БД хорошо управляется с древовидными структурами, например при нормализации и разбивке таблиц, также PostgreSQL использует иерархические запросы или таблицы-замыкания для дерева. Документная БД также подойдёт, если материалы (документы, видео) имеют разную, нежёсткую структуру и разные типы данных.
```

1.3.* Можно ли под эту задачу использовать уже существующую СУБД из задач выше и если да, то как лучше это реализовать?
```
Ответ: можно. Реализация: Создать отдельную схему или БД в уже выбранной реляционной СУБД (например, PostgreSQL из задач 1.1 или 1.2).
Если же в 1.3 выбрана Документная СУБД, то так же подойдет Документная NoSQL СУБД для лендингов из 1.2.
```

1.4. Департамент логистики нуждается в решении задач по быстрому формированию маршрутов доставки материалов по объектам и распределению курьеров по маршрутам с доставкой документов. СУБД должна уметь быстро работать со связями.
```
Ответ: Рекомендуемый тип СУБД: Графовая. Объекты (склады, стройки) — это узлы, дороги — это рёбра (связи) с весом (время, расстояние).
```

1.4.* Можно ли к этой СУБД подключить отдел закупок или для них лучше сформировать свою СУБД в связке с СУБД логистов?
```
Ответ: лучше сформировать свою СУБД в связке с СУБД логистов. Предметные области разные. Закупки — это финансы и документооборот (сильные стороны SQL), логистика — это сети и отношения (сильные стороны графовых БД). Попытка уместить всё в одну модель данных приведёт к её усложнению и потере производительности.
```

1.5.* Можно ли все перечисленные выше задачи решить, используя одну СУБД? Если да, то какую именно?
```
Ответ: Технически — да, но это будет компромиссное и не всегда оптимальное решение. Если нужна одна СУБД: PostgreSQL.
Как реализовать:
    1 Финансы: Классические реляционные таблицы.
    2 CRM/Лендинги: Реляционные таблицы + JSONB для гибких данных.
    3 База знаний: Отдельные таблицы или схема, возможно, с использованием рекурсивных запросов (WITH RECURSIVE) для иерархии.
    4 Логистика: Наибольшая проблема. Можно попытаться смоделировать граф с помощью таблиц узлов и рёбер, но запросы на поиск путей будут сложными и медленными по сравнению со специализированной графовой БД. Для небольшого числа точек это может работать.
```

---

### Задание 2. Транзакции

2.1. Пользователь пополняет баланс счёта телефона, распишите пошагово, какие действия должны произойти для того, чтобы транзакция завершилась успешно. Ориентируйтесь на шесть действий.

Ответ:
```
Как выглядит со стороны финансовой организации:

    1. Начало транзакции (BEGIN): Система начинает новую транзакцию. Все последующие изменения будут изолированы от других операций до завершения.

    2. Блокировка записи счёта пользователя (LOCK): СУБД помечает запись о счёте  на изменение. Это предотвращает параллельное списание или зачисление средств с того же счёта, которое могло бы привести к «гонке» и некорректному итогу. Обычно используется пессимистичная блокировка на уровне строки (SELECT ... FOR UPDATE).

    3. Списание средств со счета пользователя (UPDATE): Система проверяет и уменьшает баланс банковской карты / электронного кошелька пользователя на сумму пополнения. Если средств недостаточно, транзакция откатывается.

    4. Отправка сообщения компании-оператору телефона о перечислении, ответ от него об успешности и пополнении на ту же сумму. Оба шага (3 и 4) происходят в рамках одной транзакции — они либо выполнятся оба, либо оба отменятся.

    5. Фиксация изменений в лог: перед окончательным подтверждением СУБД гарантированно записывает все изменения транзакции в устойчивый журнал транзакций (redo-log). Это гарантирует долговечность (Durability). Даже если система откажет сразу после следующего шага, данные можно восстановить из этого лога.

    6. Завершение транзакции (COMMIT): СУБД официально подтверждает успешное выполнение всех операций и записывает в таблицы. Блокировки с записей снимаются, изменения становятся видимыми для других транзакций.
```

2.1.* Какие действия должны произойти, если пополнение счёта телефона происходило бы через автоплатёж?

ответ:
```
* Перед указанными 6 шагами транзакции сначала происходит следующее:
Планировщик задач (cron, Quartz) запускает процесс обработки автоплатежей для конкретного дня/периода.
* После транзакции: Регистрация результата. Независимо от исхода (успех/неудача), система фиксирует событие в таблице журнала автоплатежей.
* Пользователю отправляется сообщение о результате и дальнейших действиях.
* Далее запускается планировщик и счётчик попыток повторного списания.
* Пользователю отправляется финальное сообщение о результате списания и текущем балансе.
```

---

### Задание 3. SQL vs NoSQL

3.1. Напишите пять преимуществ SQL-систем по отношению к NoSQL.
```
Ответ.
1. Строгая согласованность данных и ACID-транзакции. Это главное преимущество для бизнес-критичных операций.
2. Универсальность и мощность языка запросов SQL. SQL — декларативный, стандартизированный язык, очень мощный для сложных аналитических запросов с множественными соединениями (JOIN), вложенными подзапросами, группировками и агрегациями. Позволяет извлекать связанные данные из многих таблиц за один запрос. В NoSQL запросы, как правило, более простые и специфичные для конкретной модели данных.
3. Жёсткая, заранее определённая схема данных. Это преимущество для задач, где целостность и структура критичны (финансы, учёт). Отсутствие мусора и неструктурированных данных. Жесткая схема и механизмы обеспечения целостности предотвращают попадание в базу некорректных или неполных данных, обеспечивая валидацию на уровне СУБД.
4. Стандартизированные механизмы обеспечения целостности. Реляционные СУБД предлагают встроенные, эффективные и проверенные способы поддержания целостности: внешние ключи автоматически следят за ссылочной целостностью, триггеры позволяют выполнять сложную бизнес-логику на уровне данных, а каскадные операции (например, удаление зависимых записей) избавляют разработчика от ручного контроля связей.
5. Зрелость, надёжность и устоявшаяся экосистема. Реляционные СУБД существуют десятилетия. Это означает проверенные временем механизмы, развитые инструменты администрирования (бэкапы, мониторинг, тонкая настройка), огромное сообщество, обширные библиотеки драйверов. Выбор NoSQL может потребовать создания собственных инструментов для решения стандартных задач.
```

3.1.* Какие, на ваш взгляд, преимущества у NewSQL систем перед SQL и NoSQL.
```
Ответ.
NewSQL — это современный класс СУБД, который ставит целью сохранить преимущества классических SQL-систем (ACID-транзакции, реляционная модель, SQL), но при этом достичь горизонтальной масштабируемости и производительности уровня NoSQL.

Преимущества NewSQL перед классическим SQL:

    Горизонтальная масштабируемость. Классические SQL (PostgreSQL, MySQL в стандартной реализации) масштабируются в основном вертикально (усиливаем сервер). NewSQL (CockroachDB, Google Spanner, YugabyteDB) изначально проектируются как распределённые кластерные системы, способные «расти» добавлением обычных серверов. Это решает главную проблему больших нагрузок.

    Распределённые ACID-транзакции. Они не просто поддерживают ACID в рамках одного узла, а обеспечивают строгую согласованность и атомарность транзакций, данные которых физически расположены на разных серверах в кластере. Для классического SQL это либо невозможно, либо требует сложных и медленных решений (шардинг).

    Высокая доступность (High Availability) «из коробки». За счёт распределённой природы и автоматической репликации данных (обычно по схеме Raft/Paxos) они обеспечивают отказоустойчивость: при падении одного или нескольких узлов кластер продолжает работать без потери данных и с минимальным простоем. В классическом SQL это требует сложной ручной настройки репликации и кластеризации.

Преимущества NewSQL перед NoSQL:

    Полноценный SQL и ACID. NoSQL часто жертвует либо согласованностью (CAP-теорема), либо возможностью сложных запросов, либо транзакциями, охватывающими несколько записей. NewSQL даёт всё сразу: и SQL для сложных запросов, и строгие ACID-транзакции.

    Единая точка истины для операционных и аналитических нагрузок (HTAP). Многие NewSQL-системы поддерживают гибридные рабочие нагрузки (Hybrid Transactional/Analytical Processing). Это позволяет выполнять аналитические запросы к актуальным, операционным данным практически в реальном времени, без необходимости строить отдельное хранилище данных (Data Warehouse) и сложные ETL-процессы. NoSQL для аналитики зачастую требует отдельной специализированной СУБД.

Идеальная ниша для NewSQL — глобальные, высоконагруженные приложения, где нужны и транзакции, и масштаб (например, финансовые сервисы, крупные SaaS-платформы).
```

---

### Задание 4. Кластеры

Необходимо производить большое количество вычислений при работе с огромным количеством данных, под эту задачу выделено 1000 машин.

На основе какого критерия будете выбирать тип СУБД и какая модель распределённых вычислений здесь справится лучше всего и почему?

```
Ответ.
Здесь ключевым становится не классический OLTP-подход (транзакции), а способность эффективно распределять вычисления и данные.

Критерии выбора типа СУБД:
    1. Архитектура MPP (Massively Parallel Processing): Это главный критерий. СУБД должна уметь автоматически разбивать запрос на множество независимых задач, выполняемых параллельно на разных узлах кластера, и затем агрегировать результаты. Без MPP 1000 машин будут простаивать.

    2. Модель хранения данных (Storage Model): Для аналитических вычислений столбцовое хранение (Columnar Storage) почти всегда предпочтительнее строчного.

    3. Отказоустойчивость на уровне вычислений (Compute Resilience): Система должна автоматически перезапускать упавшие задачи на других узлах, не требуя перезапуска всего запроса. Это критично для долгих (часы) вычислений на таком большом кластере.

    4. Отделение вычислений от хранилища (Compute-Storage Separation): Современный тренд. Позволяет масштабировать вычислительные мощности (ноды) независимо от объёма данных. Это даёт эластичность: можно запустить 1000 машин на время сложного ночного расчёта, а днём использовать 100 для обычных задач. Хранилище (например, в объектном хранилище S3) при этом общее и практически неограниченное.

    5. Поддержка сложной аналитики и Data Science: Наличие встроенных функций для статистики, машинного обучения, работы с временными рядами и геоданными. Возможность запускать пользовательский код рядом с данными, а не выгружать их.

Модель распределённых вычислений: есть современные MPP и классические MapReduce.

Для большого количества вычислений (анализ, агрегация, прогнозирование) над огромными данными на 1000 машинах лучшим выбором будет современная MPP-СУБД со столбцовым хранением и отделением вычислений от хранилища. Современная MPP-СУБД / Аналитический движок: ClickHouse, Snowflake, BigQuery, Vertica.

Почему эта модель лучше:

1. Производительность крайне высокая, низкая задержка (секунды).
2. Использует декларативный SQL. Гораздо проще для аналитиков и инженеров Оптимизатор запросов сам строит план.
3. Относительно низкая сложность эксплуатации. Многие предлагаются как облачный сервис (Snowflake, BigQuery) или имеют автоматическое управление ресурсами.
4. Данные хранятся в оптимизированном столбцовом формате с жёсткой схемой, что даёт максимальную скорость.
```
